package gd.eggs.mvc.model
{


	/**
	 * Базовая модель данных. От этого класса наследуется главная модель
	 * так же все ветки и параметры которые должны автообновляться от сервера
	 * должны наследоваться от этого класса. Все данные которые автообновляются
	 * можно будет достать из этой части модели геттером data.
	 * так же рекомендуется добавить все необходимые геттеры в каждом потомке
	 * дабы избежать лишней точки в имени параметра.
	 *
	 * Все известные параметры в приходящих с сервера данных должны быть добавлены в _data в конструкторе:
	 *        _data.someParam = new SomeClass(); //SomeClass - Это либо что-то из базовых типов, либо очередной потомок BaseDataModel
	 *
	 * так же при необходимости следует оверрайдить метод: updateNoKey(key:Object, data:Object) - этот метод занимается заполнением данных
	 * имени которых не нашел в _data.
	 *
	 * @author Dukobpa3
	 */
	public class BaseDataModel extends BaseModel
	{
		public static const DATA_MODEL_CHANGE:String = "dataModelChange";

		/** Объект для данных с сервера */
		protected var _data:Object;

		/**
		 * Конструктор. Тут инициалируется композиция с объектом-контенйером для автообновляемых данных.
		 * так же нужно в констркуторе указывать инициализацию всех нужных параметров нуждающихся в автообновлеении и вставлять их в этот объект.
		 * Имена параметров должны в точности совпадать с серверными.
		 */
		public function BaseDataModel()
		{
			super();
			_data = {};
		}

		//=====================================================================
		//	PRIVATE
		//=====================================================================
		/**
		 * Пропихивает данные полученные с сервера по веткам моделей.
		 * @param    data
		 */
		protected function deserialize(data:Object):void
		{
			for (var key:String in data) // проходим по каждому ключу данных
			{
				if (_data.hasOwnProperty(key)) // если в дате есть такой ключ
				{
					if (_data[key] is BaseDataModel) // и если этот ключ является BaseDataModel
					{
						_data[key].deserialize.call(this, data[key]) // значит в нем должен быть метод автоапдейта. Запускаем его
					}
					else // TODO фейл с коллекциями. Перенести логику из хакс-реализации
					{
						_data[key] = data[key]; // Иначе данные принимаем за базовый тип и просто приравниваем
					}
				}
				else // если же такого ключа нету
				{
					updateNoKey(key, data[key]); // то запускаем функцию занимающуюся обновлением без ключей.
				}

				update(DATA_MODEL_CHANGE, key); // Кричим во вьюху что изменили параметр.
			}
		}

		/**
		 * Оверрайдим там где надо.
		 * // TODO добавить пример реализации, а то сам забыл как пользоваться.
		 * @param    key
		 * @param    data
		 */
		protected function updateNoKey(key:String, data:Object):void
		{
			trace(key);
			_data[key] = data;
		}

		//=====================================================================
		//	ACCESSORS
		//=====================================================================

		/**
		 * Возвращает основной контейнер с автообновляемыми данными
		 * протектед, интернал, приват не конают в данном случае, пришлось паблик. // TODO namespaces?
		 * Но пользоваться напрямую очень не рекомендуется.
		 */
		public function get data():Object
		{ return _data; }

	}

}